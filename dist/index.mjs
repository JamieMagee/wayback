#!/usr/bin/env node
var i=class{url=this.getMultilineInput("url",{required:!0,trimWhitespace:!0});saveErrors=this.toBoolean(this.getInput("saveErrors",{trimWhitespace:!0}));saveOutlinks=this.toBoolean(this.getInput("saveOutlinks",{trimWhitespace:!0}));saveScreenshot=this.toBoolean(this.getInput("saveScreenshot",{trimWhitespace:!0}));constructor(){this.validate()}validate(){if(this.url.length===0)throw new Error("input.url must not be empty")}getInput(e,t){let o=process.env[`INPUT_${e.replace(/ /g,"_").toUpperCase()}`]||"";return t?.trimWhitespace?o.trim():o}getMultilineInput(e,t){let o=this.getInput(e,t);if(!o&&t?.required)throw new Error(`Input required and not supplied: ${e}`);let a=o.split(`
`).filter(n=>n!=="");return t?.trimWhitespace?a.map(n=>n.trim()):a}toBoolean(e){switch(e.toLowerCase()){case"true":return!0;case"false":return!1;default:throw new Error(`Invalid boolean input: ${e}. Expected 'true' or 'false'.`)}}};import m from"node:fs";import k from"node:os";function f(s,...e){let t=[s,...e].join(" ");console.log(`::debug::${t}`)}function d(s,...e){let t=[s,...e].join(" ");console.log(`::notice::${t}`)}function b(s,...e){let t=[s,...e].join(" ");console.log(`::warning::${t}`)}function w(s,...e){let t=[s,...e].join(" ");console.log(`::error::${t}`)}var u=(s,...e)=>f(s,...e);u.debug=(s,...e)=>d(s,...e);u.info=(s,...e)=>d(s,...e);u.warn=(s,...e)=>b(s,...e);u.error=(s,...e)=>w(s,...e);var r=u;var c=class s{static baseWaybackUrl="https://web.archive.org/save";static statusGuidRegex=/watchJob\("(?<guid>[0-9nps]{4}-[0-9a-f]{40})/;saveErrors;saveOutlinks;saveScreenshot;constructor(e){this.saveErrors=e.saveErrors,this.saveOutlinks=e.saveOutlinks,this.saveScreenshot=e.saveScreenshot}async save(e){r.info(`Starting archive process for URL: ${e}`);let t=`${s.baseWaybackUrl}/${e}`,o=new FormData;o.append("url",e);let a=[];this.saveErrors&&(o.append("capture_all","on"),a.push("errors")),this.saveOutlinks&&(o.append("capture_outlinks","on"),a.push("outlinks")),this.saveScreenshot&&(o.append("capture_screenshot","on"),a.push("screenshot")),a.length>0?r.info(`Capture options enabled: ${a.join(", ")}`):r.info("Using default capture options");try{r.info("Sending archive request to Wayback Machine...");let n=await fetch(t,{method:"POST",body:o,headers:{"User-Agent":"https://github.com/JamieMagee/wayback"}});if(!n.ok)throw r.error(`Archive request failed with status: ${n.status}`),await this.handleErrorResponse(n),new Error(`HTTP error! status: ${n.status}`);r.info("Archive request submitted successfully, extracting job ID...");let v=await n.text(),p=s.statusGuidRegex.exec(v);if(p?.groups?.guid){let h=p.groups?.guid;r.info(`Job ID extracted: ${h}`),r.info("Monitoring archive job status...");let g=await this.pollStatus(h);this.handleStatusResponse(g)}else throw r.error("Unable to extract job ID from response"),new Error("Unable to fetch status")}catch(n){throw n instanceof Error&&r.error(`Archive process failed: ${n.message}`),n}}async handleErrorResponse(e){let t=e.headers.get("x-archive-wayback-runtime-error")??void 0;if(t)switch(t){case"AdministrativeAccessControlException":r.error("This site is excluded from the Wayback Machine.");break;case"RobotAccessControlException":r.error("Blocked by robots.txt.");break;case"LiveDocumentNotAvailableException":case"LiveWebCacheUnavailableException":r.error("Unable to archive page. Try again later.");break;default:r.error("An unknown error occurred.",t)}}handleStatusResponse(e){switch(r.info(`Archive job completed with status: ${e.status}`),e.status){case"success":{r.info("Archive successfully created!");let t=this.getArchiveUrl(e);r.info(`Archive URL: ${t}`);break}case"error":r.error("Archive job failed with an error"),r.debug("Full error details:",e);break;default:r.warn(`Unexpected archive status: ${e.status}`),r.debug("Full status details:",e)}}async pollStatus(e){r.debug(`Starting status polling for job: ${e}`);let t=await this.getSaveStatus(e),o=1;for(;t.status==="pending";)r.info(`Archive job still in progress... (check ${o})`),await this.sleep(2e3),t=await this.getSaveStatus(e),o++;return r.info(`Status polling completed after ${o} check(s)`),t}async getSaveStatus(e){try{r.debug(`Checking status for job: ${e}`);let t=await fetch(`${s.baseWaybackUrl}/status/${e}`);if(!t.ok)throw r.error(`Status check failed with HTTP status: ${t.status}`),new Error(`HTTP error! status: ${t.status}`);let o=await t.json();return r.debug(`Current job status: ${o.status}`),o}catch(t){throw t instanceof Error&&r.error(`Failed to get save status: ${t.message}`),t}}async sleep(e){return new Promise(t=>setTimeout(t,e))}getArchiveUrl(e){let t=`https://web.archive.org/web/${e.timestamp}/${e.original_url}`,o=process.env.GITHUB_OUTPUT;return o&&(r.debug("Setting GitHub Actions output variable"),m.appendFileSync(o,`wayback_url=${t}${k.EOL}`,{encoding:"utf8"}),r.debug("GitHub Actions output variable set successfully")),t}};async function l(){try{let s=new i,e=new c(s);for(let t of s.url)await e.save(t)}catch(s){console.log(`::error::${s.message}`),process.exit(1)}}l().catch(console.error);
